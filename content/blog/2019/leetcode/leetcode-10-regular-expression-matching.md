+++
title = "Leetcode：#10 正则表达式匹配"
description = "Leetcode：#10 Regular Expression Matching，难度：困难"
author = "gra55"
categories = ["Leetcode"]
tags = ["动态规划", "2019"]
date = "2019-12-22"
featured = ""
featuredalt = ""
featuredpath = ""
linktitle = ""
type = "_post"
+++


# 0x00 题目描述

[#10](https://leetcode-cn.com/problems/regular-expression-matching/)

给定一个字符串 s 和一个字符规则 p，实现一个支持 `.` 和 `*` 的正则表达式匹配。其中 `.` 匹配任意单个字符，`*` 匹配零个或多个前面的那一个元素。

所谓匹配，是要涵盖整个字符串 s，而不是 s 的子串。类似于 re.match 而不是 re.search。

```shell
输入: s = "aa" p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

# 0x01 约束

+ s 可能为空，且只包含 a-z 的小写字母
+ p 可能为空，且只包含 a-z 的小写字母，以及字符 `.` 和 `*`

# 0x02 题解

> + 一般看到 `最长`、`最优` 等**求最优解**的题目，首先应该想到动态规划。
> 
> + **看到一个题，你首先应该能想到用什么现有的算法来解决，如果第一眼匹配不到现有的算法，那基本这个题你是解不出来的。因为不是专门研究算法的同学，能想到新的优秀的算法是很难的。**

## 算法 1：无头绪

开始拿到这个题，我感觉无从下手，想不到什么好的办法（没有头绪）。

只是想到 s 和 p 各拿一个指针，从左到右的扫描。接下来需要进行各种 if else 的判断，而且判断条件很复杂，不一定能做出来。

## 算法 2：动态规划

开始没有想到这个题还可以使用 DP。

那么什么样的问题可以使用 DP 呢？
+ 关键点是：问题可以被拆分成子问题（要不然要状态干嘛！），子问题无后效性（也就是说子问题求解出来以后，后面的计算就不用关心前面的子问题了），
+ **不要以为看到最优子结构这类问题才能用 DP。**
+ DP 的核心是缩小解的空间，暴力破解是全局解，DP 排除了不可能成为最优解的项
+ [什么是动态规划？- 徐凯强 Andy的回答 - 知乎](https://www.zhihu.com/question/23995189/answer/35324479)
+ 动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义，在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。

再回到这个问题上来。

那就是对正则表达式问题进行重新定义，找到状态和状态转移方程。
+ 状态：`dp[i][j]` 表示 p[0:i] 是否能匹配 s[0:j]，状态值是 0 或者 1
+ 转移方程：

```python

```

PS：动态规划的时间复杂度其实也不小（O(n²)），只是避免了很多重复的计算。

---
参考：

:pushpin: [什么是动态规划（Dynamic Programming）？](https://www.zhihu.com/question/23995189)